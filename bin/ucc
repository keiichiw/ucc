#!/usr/bin/env python2.7

import os
import sys
import subprocess
import argparse

BIN_DIR = os.path.dirname(__file__)
CC = BIN_DIR+'/cc'
AS = BIN_DIR+'/as'
LIBS = ['{b}/../lib/libucc.s'.format(b = BIN_DIR)]
UCCLIB_INCLUDE_DIR = '{b}/../include'.format(b = BIN_DIR)
OUTFILE = 'a.out'
OFLAG = False

CPPOPTS = ['-undef', '-nostdinc',
         '-D__UCC__', '-Dinline=',
         '-I{d}'.format(d = UCCLIB_INCLUDE_DIR)]
CLANGOPTS = ['-fsyntax-only', '-w', '-ansi',
           '-pedantic-errors', '-Werror=implicit',
           '-Werror=aggregate-return', '-Wno-overlength-strings',
           '-fno-builtin']

ASMOPTS = ""
ASMS = []
ASM_MODE = False

# parse command line arguments
argparser = argparse.ArgumentParser(usage = '%(prog)s [options] file...')

argparser.add_argument('inputs', nargs = '*', help = 'input files', metavar = 'file...')
argparser.add_argument('-a', help = 'set assembler option',
                       default="", metavar = '=<option>', type=str)
argparser.add_argument('-c', help = 'set clang\'s syntax check option',
                       action = 'append', default = [], metavar = '<option>')
argparser.add_argument('-I', help = 'set include path',
                       action = 'append', default = [],metavar = '<dir>')
argparser.add_argument('-o', help = 'set output file name',
                       metavar = '<outfile>')
argparser.add_argument('-s', help = 'do not assemble',
                       action = 'store_true')
argparser.add_argument('-l', help = 'search the library when linking',
                       action = 'append', default = [], metavar = '<library>')
argparser.add_argument('-D', help = 'predefine name as a macro when preprocessing',
                       action = 'append', default = [], metavar = '<macro>')


def set_flags(args):
    global ASM_MODE
    global OUTFILE
    global OFLAG
    global LIBS
    global CPPOPTS
    global ASMOPTS
    global CLANGOPTS

    if args.inputs == []:
        argparser.print_help(sys.stderr)
        exit(1)

    ASM_MODE  = args.s

    if args.o:
        OUTFILE = args.o
        OFLAG = True

    if args.a:
        ASMOPTS = args.a

    LIBS.extend(['{b}/../lib/lib{l}.s'.format(b = BIN_DIR, l = lib) for lib in args.l])

    CPPOPTS.extend(['-I{inc}'.format(inc = i) for i in args.I])
    CPPOPTS.extend(['-D{df}'.format(df = d) for d in args.D])

    CLANGOPTS.extend(args.c)


def call(cmd):
    try:
        subprocess.check_output(cmd.split())
    except:
        sys.stderr.write('Error: ' + cmd)
        rm = 'rm -f {a}'.format(a=' '.join(ASMS))
        subprocess.call(rm.split())
        exit(1)

def compile(filename) :
    global ASMS
    fname, ext = os.path.splitext(filename)
    dic = {
        'cppopt': ' '.join(CPPOPTS),
        'file'  : filename,
        'f'     : fname,
        'sopt'  : ' '.join(CLANGOPTS),
        'cc'    : CC,
        'out'   : OUTFILE
    }

    # preprocess
    cmd = 'clang -E {cppopt} {file} -o {f}.tmp.i'.format(**dic)
    call(cmd)

    # syntax check
    cmd = 'clang {sopt} {f}.tmp.i'.format(**dic)
    call(cmd)

    # compile
    cmd = '{cc} {f}.tmp.i'.format(**dic)
    call(cmd)

    # remove .i
    cmd = 'rm -f {f}.tmp.i'.format(**dic)
    call(cmd)

    # rename & push
    if ASM_MODE:
        if OFLAG:
            call('mv -f {f}.tmp.s {out}'.format(**dic))
        else:
            call('mv -f {f}.tmp.s {f}.s'.format(**dic))
    else:
        ASMS.append('{f}.tmp.s'.format(**dic))

def assemble():
    dic = {
        'as' :AS,
        'opt' : ASMOPTS,
        'asms': ' '.join(ASMS),
        'lib' : ' '.join(map(lambda s: '-l '+s, LIBS)),
        'out' : OUTFILE
    }

    cmd = '{as} {opt} {asms} {lib} -o {out} -f __UCC_HEAP_START'.format(**dic)

    call(cmd)

    call('rm -f {asms}'.format(**dic))



if __name__ == '__main__':

    args = argparser.parse_args()

    set_flags(args)

    for f in args.inputs:
        compile(f)

    if ASM_MODE:
        exit(0)

    assemble()
